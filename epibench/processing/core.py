import numpy as np
import pandas as pd
from scipy import stats
import subprocess
from typing import Tuple, Optional, Dict, Any, List

# Assuming BaseGenomicData classes are available, e.g., from epibench.data.base
# from ..data.base import MethylationData, SequenceData, HistoneMarkData # Relative import

def wilson_score_interval(successes: int, trials: int, confidence: float = 0.95) -> Tuple[float, float]:
    """
    Calculate the Wilson score interval for a binomial proportion.

    Args:
        successes: Number of successful trials (e.g., methylated reads).
        trials: Total number of trials (e.g., total coverage).
        confidence: Confidence level (default: 0.95).

    Returns:
        A tuple containing the lower and upper bounds of the confidence interval.
        Returns (nan, nan) if trials is 0.
    """
    if trials == 0:
        return (np.nan, np.nan)

    successes = float(successes)
    trials = float(trials)
    
    z = stats.norm.ppf(1 - (1 - confidence) / 2)  # Z-score for the desired confidence level
    p_hat = successes / trials
    
    denominator = 1 + z**2 / trials
    center = p_hat + z**2 / (2 * trials)
    margin = z * np.sqrt((p_hat * (1 - p_hat) / trials) + (z**2 / (4 * trials**2)))
    
    lower_bound = (center - margin) / denominator
    upper_bound = (center + margin) / denominator
    
    # Ensure bounds are within [0, 1]
    lower_bound = max(0.0, lower_bound)
    upper_bound = min(1.0, upper_bound)
    
    return (lower_bound, upper_bound)

def calculate_confidence_intervals(methylation_df: pd.DataFrame, confidence: float = 0.95) -> pd.DataFrame:
    """
    Calculate Wilson score confidence intervals for methylation data.

    Requires 'count_methylated' and 'coverage' (or 'count_unmethylated') columns
    in the input DataFrame. Adds 'ci_lower' and 'ci_upper' columns.

    Args:
        methylation_df: DataFrame containing methylation counts.
                        Must have 'count_methylated' and either 'coverage'
                        or 'count_unmethylated'.
        confidence: Confidence level for the interval (default: 0.95).

    Returns:
        The DataFrame with added 'ci_lower' and 'ci_upper' columns.
        Returns the original DataFrame if required columns are missing.
    """
    # Handle empty DataFrame early
    if methylation_df.empty:
         methylation_df['ci_lower'] = pd.Series(dtype=float)
         methylation_df['ci_upper'] = pd.Series(dtype=float)
         return methylation_df

    if 'count_methylated' not in methylation_df.columns:
        print("Error: 'count_methylated' column missing for CI calculation.")
        return methylation_df

    if 'coverage' in methylation_df.columns:
        if not pd.api.types.is_numeric_dtype(methylation_df['coverage']):
             print("Error: 'coverage' column must be numeric for CI calculation.")
             return methylation_df
        coverage_col = 'coverage'
    elif 'count_unmethylated' in methylation_df.columns:
         if not pd.api.types.is_numeric_dtype(methylation_df['count_unmethylated']):
              print("Error: 'count_unmethylated' column must be numeric for CI calculation.")
              return methylation_df
         # Calculate coverage if not present
         methylation_df['coverage'] = methylation_df['count_methylated'] + methylation_df['count_unmethylated']
         coverage_col = 'coverage'
    else:
        print("Error: Requires either 'coverage' or 'count_unmethylated' column for CI calculation.")
        return methylation_df

    if not pd.api.types.is_numeric_dtype(methylation_df['count_methylated']):
        print("Error: 'count_methylated' column must be numeric for CI calculation.")
        return methylation_df

    # Apply Wilson score interval calculation row-wise
    # Vectorization might be possible but apply is straightforward
    intervals = methylation_df.apply(
        lambda row: wilson_score_interval(row['count_methylated'], row[coverage_col], confidence),
        axis=1
    )
    
    methylation_df[['ci_lower', 'ci_upper']] = pd.DataFrame(intervals.tolist(), index=methylation_df.index)
    
    return methylation_df

def run_methfast(input_file: str, output_prefix: str, methfast_path: str = "methfast", options: Optional[List[str]] = None) -> bool:
    """
    Placeholder function to run an external tool like MethPipe's methfast.

    Args:
        input_file: Path to the input file for methfast.
        output_prefix: Prefix for the output files generated by methfast.
        methfast_path: Path to the methfast executable (default: assume in PATH).
        options: Additional command-line options for methfast.

    Returns:
        True if the command executed successfully (exit code 0), False otherwise.
    """
    command = [methfast_path]
    if options:
        command.extend(options)
    command.extend([input_file, output_prefix]) # Example command structure

    print(f"Running command: {' '.join(command)}")
    try:
        result = subprocess.run(command, check=True, capture_output=True, text=True)
        print("Methfast completed successfully.")
        print("STDOUT:", result.stdout)
        print("STDERR:", result.stderr)
        return True
    except FileNotFoundError:
        print(f"Error: '{methfast_path}' command not found. Is MethPipe installed and in PATH?")
        return False
    except subprocess.CalledProcessError as e:
        print(f"Error running Methfast (exit code {e.returncode}):")
        print("STDOUT:", e.stdout)
        print("STDERR:", e.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred while running Methfast: {e}")
        return False

def process_sample(sample_id: str, config: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    High-level function to process a single sample based on configuration.

    This is a placeholder and needs significant expansion based on the
    actual processing steps required to generate the (N_samples, 10000, 11) matrices.
    It might involve steps like:
    1. Aligning reads (if starting from FASTQ - likely out of scope based on PRD)
    2. Calling methylation (e.g., using Bismark, Methyldackel)
    3. Extracting methylation data (using MethylationData class)
    4. Extracting relevant sequence data (using SequenceData class)
    5. Extracting histone mark signals (using HistoneMarkData class)
    6. Combining data into the final matrix format.

    Args:
        sample_id: Identifier for the sample.
        config: Dictionary containing configuration parameters (file paths, tool paths, etc.).

    Returns:
        A dictionary containing processed data (e.g., paths to output matrices)
        or None if processing fails.
    """
    print(f"Processing sample: {sample_id}")
    
    # --- Placeholder Example Steps ---
    # 1. Define file paths based on sample_id and config
    methylation_input = config.get('methylation_files', {}).get(sample_id)
    histone_inputs = config.get('histone_files', {}).get(sample_id, []) # Expect a list of histone BigWigs
    sequence_input = config.get('sequence_file') # Assume one reference genome
    output_dir = config.get('output_directory', '.')
    
    if not methylation_input:
         print(f"Error: Missing methylation input file path for sample {sample_id}")
         return None

    # 2. Load Methylation Data (example using Bismark cov)
    # meth_data = MethylationData()
    # meth_data.load_data(methylation_input, file_format='bismark_cov')
    # if not meth_data.validate_data():
    #     print(f"Error validating methylation data for {sample_id}")
    #     return None
    # Example: Calculate CIs if counts are available
    # if 'count_methylated' in meth_data.get_data().columns:
    #     meth_data.methylation_levels = calculate_confidence_intervals(meth_data.get_data())

    # 3. Run methfast (if needed by the workflow) - Requires specific input/output understanding
    # methfast_output = f"{output_dir}/{sample_id}_methfast_out"
    # if not run_methfast(some_input_for_methfast, methfast_output, config.get('methfast_path')):
    #     print(f"Error running methfast for {sample_id}")
    #     return None

    # 4. Load Sequence Data (likely only needed once)
    # seq_data = SequenceData()
    # seq_data.load_data(sequence_input)
    # if not seq_data.validate_data(): return None # Handle error

    # 5. Load Histone Data
    # histone_data_objects = []
    # for histone_file in histone_inputs:
    #     hist_data = HistoneMarkData(histone_file)
    #     if not hist_data.validate_data():
    #         print(f"Warning: Could not load or validate histone file {histone_file} for {sample_id}")
    #         # Decide whether to continue without this mark or fail
    #     else:
    #         histone_data_objects.append(hist_data)

    # 6. Generate the final matrix (Core Logic Missing!)
    # This is the most complex part: requires defining regions (e.g., 10kb windows),
    # fetching sequence, methylation, and histone signals for each window,
    # and assembling them into the (N_windows, 10000, 11) matrix format.
    # This likely involves looping through chromosomes/regions and calling
    # get_sequence(), get_methylation_at(), get_signal_in_region().
    print(f"Placeholder: Core matrix generation logic for {sample_id} needs implementation.")
    output_matrix_path = f"{output_dir}/{sample_id}_processed_matrix.h5" # Example output

    # 7. Clean up (e.g., close BigWig files)
    # for hist_data in histone_data_objects:
    #      hist_data.close()

    print(f"Finished processing sample: {sample_id}")
    return {"processed_matrix_path": output_matrix_path} # Return path to result
